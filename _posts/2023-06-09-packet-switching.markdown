---
layout: post
title: packet-switching
date: 2023-06-09 10:00:00 +0900
description:  # Add post description (optional)
img:  # Add image post (optional)
---

### **패킷이란?**

네트워크 애플리케이션에서는 end system 끼리 메시지 교환이 일어나게 됩니다. 목적지 까지 메시지를 전송하기 위해서는 메시지를 작은 조각으로 쪼개게 되고, 우리는 이를 **패킷**이라고 부릅니다.

패킷은 각 커뮤니케이션 링크의 최대 전송속도와 동일하게 링크를 타고 전송이 되기 때문에 패킷의 전송 시간은

L / R ( L : 전체 패킷의 비트 수, R : 링크의 전송속도 bits/sec) 만큼 걸리게 됩니다.

### Store-and-Forward (축적 교환)

패킷은 어떤 방식으로 전송이 될까요? 대부분의 경우에 패킷은 **store-and-forward(축적 교환)** 방식을 이용합니다. store-and-forward 방식에서는 패킷 스위치가 패킷의 첫 비트를 outboud link에 전송하기 위해서는 전체 패킷을 모두 수신해야하만 합니다. 즉 일부만 먼저 받고, 먼저 보내는 행위는 불가능합니다.

![sotre-and-forward]({{site.baseurl}}/assets/img/store-and-forward.png)

위 그림 1은 Store-and-Forward 방식을 나타내는 그림입니다. 첫번째 패킷이 라우터로 출발했다고 합시다. 가장 먼저 도착한 첫번째 패킷은 먼저 가고 싶겠지만 마지막 패킷이 도착하기를 기다려야 합니다. 첫 패킷이 출발하고  L / R초가 지나면 마지막 패킷까지 라우터에 도착하기 때문에 드디어 첫번째 패킷이 라우터에서 목적지로 출발 할 수 있게 됩니다. 출발지에서 라우터까지 L / R 초가 걸린것과 동일하게 라우터부터 목적지까지도 L / R초가 걸립니다. 즉 한개의 패킷이 목적지까지 도착하는데에 2L / R초가 걸리게 됩니다.

이제 우리는 한개의 패킷이 목적지까지 도달하는데 2L / R초가 걸린다는 사실을 알았습니다. 그렇다면 그림처럼 세개의 패킷이 도착하는데에는 얼마나 걸릴까요? 세개니까 3을 곱하면 되지 않을까? 하실 수 있겠지만, **그것은 틀렸습니다**. 첫번째 패킷이 라우터를 거쳐 목적지까지 도착한 뒤에 두번째 패킷이 출발하는 것이 아니기 때문입니다. 첫 패킷이 목적지를 향해 출발하는 순간부터 출발지에서는 두번째 패킷의 첫 번째 비트가 출발하게 됩니다. 즉 첫번째 패킷이 온전히 목적지에 도착하는 2L / R초가 되면, 두번째 패킷의 모든 비트는 라우터에 도착하게 됩니다. 결과적으로 두개의 패킷이 목적지까지 도착하는데에 3L / R이 걸린다는 것을 알 수 있습니다. 두번째 패킷의 첫번째 비트가 목적지로 출발하면서부터 세번째 패킷의 첫 비트가 라우터를 향해 출발하기 때문에 세개의 패킷을 모두 전송하는데 걸리는 시간은 4L / R초가 됩니다.

### Queuing Delay와 Packet Loss

실제 라우터는 그림 1. 처럼 한개의 input link 와 output link를 가지지 않습니다. 복수의 input과 복수의 output link에 연결이 되어있습니다. 패킷 스위치에 연결된 각각의 링크에는 **Output Buffer (Output Queue)**가 연결되어 있고, 여기에 패킷이 축적되고 링크로 전송됩니다. 만약 어떤 패킷A 가 B 목적지로 향하는 링크로 전송되어야 하는데, 해당 링크가 이미 다른 패킷을 전송중이라면 어떻게 될까요? 이때 패킷 A는 기존에 전송중이던 패킷이 전송 완료될 때 까지 Output Buffer에서 대기해야합니다. 패킷 A의 **전송이 시작될 때 까지 Output Buffer에서 대기하는 시간을 우리는 Queuing Delay라고 합니다**.

그렇다면 Packet Loss는 언제 발생할까요? 우리는 패킷이 대기하는 Buffer가 크기가 유한하다는 사실에 주목해야합니다. 출근길 지하철을 탑승할 때 지하철이 가득 차있다면 우리는 탑승하지 못한채 버려지고, 열차는 매정하게 떠나버립니다. 패킷도 비슷한 경험을 하게 됩니다. 도착하는 Output Buffer가 가득 차 있는 상황에서 새로운 패킷이 해당 Buffer로 전송되어 도착한다면, **Buffer에 들어갈 자리가 없어 도착한 패킷이 버려지거나, Buffer에 대기중이던 어떤 패킷이 버려지게 됩니다**. 이러한 상황을 Packet Loss가 발생했다고 표현합니다.

참고 : James F.Kurose, Computer Networking A Top-Down Approach, Pearson, 8th edition
